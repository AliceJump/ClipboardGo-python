# import json
# import os
# import subprocess
# import re
# import win32clipboard
# import win32con
# from io import BytesIO
# from PIL import Image
# from bs4 import BeautifulSoup
#
# CONFIG_FILE = "config.json"
#
# DEFAULT_CONFIG = [
#     [
#         "notepad",
#         "*.txt",
#         "{text}"
#     ],
#     [
#         "C:\\Program Files\\Microsoft Office\\root\\Office16\\OUTLOOK.EXE",
#         "([a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+)",
#         "/c ipm.note /m {text}"
#     ],
#     [
#         "C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe",
#         "((?:https?://)?[\\w.-]+\\.[a-zA-Z]{2,}(?:/[^\\s]*)?)",
#         "{text}"
#     ]
# ]
#
#
# # ---------------- 配置相关 ----------------
# def ensure_config_exists():
#     if not os.path.exists(CONFIG_FILE):
#         with open(CONFIG_FILE, "w", encoding="utf-8") as file:
#             json.dump(DEFAULT_CONFIG, file, ensure_ascii=False, indent=4)
#         print(">>> 配置文件不存在，已自动创建默认 config.json\n")
#
#
# def load_config():
#     ensure_config_exists()
#     with open(CONFIG_FILE, "r", encoding="utf-8") as file:
#         conf = json.load(file)
#     if not isinstance(conf, list) or not all(
#             isinstance(i, list) and len(i) == 3 for i in conf):
#         raise ValueError("config.json 格式错误，应为 [[软件路径, 匹配格式, 参数格式], ...]")
#     return conf
#
#
# def is_wildcard_format(fmt: str):
#     return fmt.startswith("*.") and len(fmt) > 2
#
# def match_and_extract(text: str, fmt: str):
#     # 先处理通配符
#     if is_wildcard_format(fmt):
#         ext = os.path.splitext(text)[1].lower()
#         if ext == fmt[1:].lower():
#             return True, text
#         return False, None
#
#     try:
#         m = re.search(fmt, text)
#         if not m:
#             return False, None
#
#         groups = m.groups()
#         if len(groups) == 0:
#             return True, text
#         elif len(groups) == 1:
#             return True, groups[0]
#         else:
#             raise ValueError("只允许一个捕获组")
#     except re.error:
#         return False, None
#
#
#
# def match_format(text: str, fmt: str) -> bool:
#     if is_wildcard_format(fmt):
#         ext = os.path.splitext(text)[1].lower()
#         return ext == fmt[1:].lower()
#     try:
#         return re.fullmatch(fmt, text) is not None
#     except re.error:
#         return False
#
#
# def find_software_for_file(text: str):
#     conf = load_config()
#     for path, fmt, arg_fmt in conf:
#         matched, extracted = match_and_extract(text, fmt)
#         if matched:
#             return path, arg_fmt, extracted
#     return None, None, None
#
#
#
# def open_with_software(text, item_type=None):
#     # ---------- 强语义优先 ----------
#     if item_type == "files":
#         print(">>> 打开文件")
#         print(f"文件路径: {text}")
#         os.startfile(text)
#         return
#
#     if item_type == "image":
#         print(">>> 剪贴板图片已处理")
#         return  # 已经处理过
#
#     # ---------- text 才继续判断 ----------
#     soft, arg_fmt, extracted = find_software_for_file(text)
#     if not soft:
#         print(">>> 未找到匹配的软件")
#         print(f"内容: {text}")
#         return
#
#     final_text = extracted if extracted is not None else text
#
#     args = []
#     for part in arg_fmt.split():
#         args.append(part.replace("{text}", final_text))
#
#     # ---------- 打开详情 ----------
#     print(">>> 打开方式详情")
#     print(f"类型: {item_type}")
#     print(f"原始内容: {text}")
#     if extracted is not None:
#         print(f"提取内容: {extracted}")
#     print(f"使用软件: {soft}")
#     print(f"参数格式: {arg_fmt}")
#     print(f"最终参数: {' '.join(args)}")
#     print("-" * 40)
#
#     subprocess.Popen([soft] + args, creationflags=0x08000000)
#
#
#
#
# def get_clipboard():
#     """
#     返回剪贴板内容列表，每一项是一个字典：
#     {
#         "type": "text" / "files" / "image",
#         "content": 对应内容
#     }
#
#     处理逻辑：
#     - 如果存在 HTML 内容，则渲染 HTML 提取文本并 strip
#     - 否则使用纯文本 strip
#     - 文件和图片保持原样
#     """
#     clipboard_data = []
#     win32clipboard.OpenClipboard()
#     try:
#         text_item = None
#         html_item = None
#
#         # 文本
#         if win32clipboard.IsClipboardFormatAvailable(win32con.CF_UNICODETEXT):
#             text = win32clipboard.GetClipboardData(win32con.CF_UNICODETEXT)
#             text_item = text  # 先保存，等优先级判断
#
#         # 文件列表
#         if win32clipboard.IsClipboardFormatAvailable(win32con.CF_HDROP):
#             files = win32clipboard.GetClipboardData(win32con.CF_HDROP)
#             clipboard_data.append({"type": "files", "content": list(files)})
#
#         # 图片
#         if win32clipboard.IsClipboardFormatAvailable(win32con.CF_DIB):
#             dib = win32clipboard.GetClipboardData(win32con.CF_DIB)
#             if isinstance(dib, str):
#                 dib = dib.encode('latin1')
#             image = Image.open(BytesIO(dib))
#             clipboard_data.append({"type": "image", "content": image})
#
#         # HTML
#         cf_html = win32clipboard.RegisterClipboardFormat("HTML Format")
#         if win32clipboard.IsClipboardFormatAvailable(cf_html):
#             html = win32clipboard.GetClipboardData(cf_html)
#             html_item = html  # 保存 HTML，优先处理
#
#         # 处理文本优先级：HTML > Text
#         final_text = None
#         if html_item:
#             if isinstance(html_item, bytes):
#                 html_str = html_item.decode('utf-8', errors='ignore')
#             else:
#                 html_str = str(html_item)
#             start_idx = html_str.find("<!--StartFragment-->")
#             end_idx = html_str.find("<!--EndFragment-->")
#             if start_idx != -1 and end_idx != -1:
#                 start_idx += len("<!--StartFragment-->")
#                 fragment = html_str[start_idx:end_idx]
#             else:
#                 fragment = html_str
#             final_text = BeautifulSoup(fragment, "html.parser").get_text().strip()
#         elif text_item:
#             final_text = text_item.strip()
#
#         if final_text:
#             clipboard_data.append({"type": "text", "content": final_text})
#         return clipboard_data
#
#     finally:
#         win32clipboard.CloseClipboard()
#
# def choose_clipboard_item(items):
#     # files 优先
#     for item in items:
#         if item["type"] == "files":
#             return item
#
#     # image 次之
#     for item in items:
#         if item["type"] == "image":
#             return item
#
#     # 最后 text
#     for item in items:
#         if item["type"] == "text":
#             return item
#
#     return None
#
#
# # ---------------- 主流程 ----------------
# if __name__ == "__main__":
#     ensure_config_exists()
#
#     print("当前配置：")
#     for s, f, a in load_config():
#         print(f"  软件: {s}   格式: {f}   参数格式: {a}")
#     print("\n检测剪贴板内容...\n")
#
#     clipboard_items = get_clipboard()
#     item = choose_clipboard_item(clipboard_items)
#
#     print(f"类型: {item['type']}")
#     if item['type'] == "image":
#         print("剪贴板包含图片，可用PIL处理。")
#         item['content'].show()
#     elif item['type'] == "files":
#         for f in item['content']:
#             open_with_software(f, item_type="files")
#     else:
#         open_with_software(item['content'], item_type="text")
#
#     print("-" * 40)